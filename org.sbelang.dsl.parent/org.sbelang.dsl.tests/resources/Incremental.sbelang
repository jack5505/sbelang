schema org.sbelang.examples.v2.Incremental 
    id = 1 version = 100
//  headerType = a.b.c.D
//  bigEndian

types
{
    simpleType t_char : char
    simpleType t_int8 : int8
    simpleType t_int16 : int16
    simpleType t_int32 : int32
    simpleType t_int64 : int64
    simpleType t_uint8 : uint8
    simpleType t_uint16 : uint16
    simpleType t_uint32 : uint32
    simpleType t_uint64 : uint64
//   simpleType t_Char : int8 // same name in different letter case
//   simpleType t_char : int16 // exactly same name
    simpleType t_float : float
    simpleType t_double : double
    //
    // arrays --------------------------------
    //
    simpleType array_char : char[42]
    simpleType array_int8 : int8[16]
    simpleType array_int16 : int16[8]
    simpleType array_int32 : int32[4]
    simpleType array_int64 : int64[2]
    simpleType array_uint8 : uint8[16]
    simpleType array_uint16 : uint16[8]
    simpleType array_uint32 : uint32[4]
    simpleType array_uint64 : uint64[2]
    simpleType array_float : float[4]
    simpleType array_double : double[2]

    composite CompPrimitives
    {
        t_char     : char // member name does not collide with simple type
        primChar   : char
        primInt8  : int8
        primInt16 : int16
        primInt32 : int32
        primInt64 : int64
        primUint8  : uint8
        primUint16 : uint16
        primUint32 : uint32
        primUint64 : uint64
        // primChaR   : char // same name in different letter case
        // primChar   : int8 // exactly same name
        primFloat  : float
        primDouble : double
        //
        // arrays
        //
        arr_primChar   : char[24]
        arr_primInt8  : int8[16]
        arr_primInt16 : int16[8]
        arr_primInt32 : int32[4]
        arr_primInt64 : int64[2]
        arr_primUint8  : uint8[16]
        arr_primUint16 : uint16[8]
        arr_primUint32 : uint32[4]
        arr_primUint64 : uint64[2]
        arr_primFloat  : float[4]
        arr_primDouble : double[2]
    }

//    composite CompPrimitives { // composite name collides with existing composite
//        this_composite_name_should_collide_with_the_one_above : char
//    }
    composite CompSimpleTypes
    {
        t_char       : t_char // member name does not collide with simple type
        st_char      : t_char
        st_int8      : t_int8
        st_int16     : t_int16
        st_int32     : t_int32
        st_int64     : t_int64
        st_uint8     : t_uint8
        st_uint16    : t_uint16
        st_uint32    : t_uint32
        st_uint64    : t_uint64
        // st_chAr   : char // same name in different letter case
        // st_char   : t_char // exactly same name
        st_float  : t_float
        st_double : t_double
//       st_char_array   : t_char[123] // length not allowed here!
//       st_enum_array   : EnumChar[123] // length not allowed here!
//       st_set_array   : Set32[123] // length not allowed here!
        arr_st_char  : array_char // but you can refer to an array...
        arr_st_int32 : array_int32
//   composite CompPrimitives { // nested composite name collides with existing composite
//       normal_member_char : char
//   }
    }

    enum EnumChar : char
    {
        YES('Y')
        NO('N')
    }

    enum EnumUint8 : uint8
    {
        YES(1)
        NO(0)
    }

    enum EnumUint16 : uint16
    {
        YES(10001)
        NO(10000)
    }

//  enum CompSimpleTypes : char { // enum name collides with composite name
//      NORMA_VALUE('X')
//  }
//  composite EnumUint8 { // composite name collides with enum
//      m_enum_char     : EnumChar
//  }
    composite CompEnums
    {
        m_enum_char     : EnumChar
//       m_array_enum_char     : EnumChar[3] // length is illegal in enumeration references
        m_enum_uint8    : EnumUint8
        m_enum_uint16   : EnumUint16

//      enum CompSimpleTypes : char { // nested enum name collides with composite name
//          NORMA_VALUE('X')
//      }
//      composite EnumUint8 { // nested composite name collides with enum
//          m_enum_char     : EnumChar
//      }
        enum EnumNestedChar : char
        {
            A('A')
            B('B')
            C('C')
        }
    }

    set Set8 : uint8
    {
        zero(0)
        seven(7)
    }

    set Set16 : uint16
    {
        zero (0)
        fifteen (15)
    }

    set Set32 : uint32
    {
        zero (0)
        thirtyOne (31)
    }

    set Set64 : uint64
    {
        zero(0)
        sixtyThree(63)
    }

//  set CompSimpleTypes : uint16 { // set name collides with composite name
//      ZERO(0)
//  }
//  composite Set16 { // composite name collides with set
//      m_set_32     : Set32
//  }
//  enum Set32 : char { // set name collides with enum name
//    NORMA_VALUE('X')
//  }
    composite CompSets
    {
        m_set_8     : Set8
        m_set_16    : Set16
        // m_array_set_16     : Set16[3] // length is illegal in set references
        m_set_32    : Set32
        m_set_64    : Set64

//      set CompSimpleTypes : uint16 { // set name collides with composite name
//          ZERO(0)
//      }
//      composite Set16 { // nested composite name collides with set
//          m_set_32     : Set32
//      }
        set SetNested16 : uint16
        {
            nestedZero(0)
            nestedFifteen(15)
        }
    }

    /*================================================================================================
     * The section above covers all core features. Every kind of type declaration (simple/enum/set and
     * composite) is demonstrated, along with all kinds of inline/reference members for composites. We
     * also covered arrays (from simple types or member types that are primitives) and finally we have
     * provided commented-out examples for all kinds of syntactically-correct but semantically-illegal
     * cases (unique member names in same composite/enum/set, unique names for inline sets enumerations
     * and composites across the entire schema).
     */
    /*
     * 
     * 
     * ================================================================================================
     * The next section deals with range/presence attributes.
     * 
     * Range and presence can only be defined for message fields and for in composite member data types.
     * 
     * 
     */
    composite CompRanges
    {
        m_char_lower        : char range=['a', 'z']
        m_int8_2_digits     : int8 range=[-99, 99]
        m_int16_4_digits    : int16 range = [-9999, 9999]
        m_int32_6_digits    : int32 range = [-999999, 999999]
        m_int64_10_digit    : int64 range = [-9999999999, 9999999999]
        // range specification errors -----------------------
//       m_char_range_inverted    : char range=['z', 'a']
//       m_int_range_inverted     : int8 range=[5, -1]
//       m_uint_range_inverted    : uint8 range=[5, 0]
//       m_int_max_out_of_range   : int8 range=[1, 128]
//       m_uint_max_out_of_range  : uint8 range=[0, 256]
//       m_int_min_out_of_range   : int8 range=[-129, 127]
//       m_uint_min_out_of_range  : uint8 range=[-1, 255]
        m_uint8_2_digits    : uint8 range=[0, 99]
        m_uint16_4_digits   : uint16 range = [0, 9999]
        m_uint32_6_digits   : uint32 range = [0, 999999]
        m_uint64_10_digit   : uint64 range = [0, 9999999999]
        /*
         * Enums and sets cannot have a range as that is defined by the list of values. Composites cannot
         * have a range as it would not make sense (they comprise of many items each with its own range).
         * For each member of a composite the range is specified for by that item. Enums/sets automatically
         * define their range from their content and member data types can specify it as per below examples.
         * References to enums/sets use their target's range and REFERENCES TO SIMPLE TYPES CAN NOT have a
         * range but if one is required they can simply replace the reference with an inline member type
         * definition (same primitive/length but with range attribute).
         */
        m_float : float // TODO: support float range
        m_double : double // TODO: support double range
        // ------------------------------------------------------
        // Ranges can NOT be applied to simple type references
        // m_t_char_lower      : t_char   range = ['a', 'z']
        // m_t_int8_2_digits   : t_int8   range = [-99, 99]
        // m_t_int16_4_digits  : t_int16  range = [-9999, 9999]
        // m_t_int32_6_digits  : t_int32  range = [-999999, 999999]
        // m_t_int64_10_digit  : t_int64  range = [-9999999999, 9999999999]
        // m_enum_range        : EnumChar range = ['a','z']
        // m_set_range         : Set16    range = [1, 5]
    }

    composite CompPresence
    {
        /*
         * Since composites are treated as a whole, each specific use of a composite in a message field will
         * apply the presence of that field to the entire composite. As such, a composite in itself has no
         * presence: only when used through a field does it acquire one.
         * 
         * A field using a composite can only be set to required or optional (you can not specify a constant
         * composite).
         * 
         * For optional composites, the first member is used to encode the absence of the entire composite.
         * The rest of the members should be ignored if that member is set to the null value. For composite 
         * fields that are required, the first member of the composite must never be set to its null value.
         * 
         * Individual members of a composite can still have presence to define whether they are required or
         * not. When a composite is present (first field not absent) then each of the rest of the fields may
         * or may not be present. If a composite is absent (first field is absent) the rest of the fields
         * should not be parsed.
         * 
         * A consequence of the above is that it is impossible to reliably encode a composite where its first
         * field *only* is absent, with some of the rest being present, because the first field defines the
         * presence for the entire composite. In cases where this is required, message designers must rearrange
         * the fields so that another field is first, and add an extra field for that purpose (e.g. add field
         * 'present : char optional' as the first member).
         * 
         * Technically it is an error to define a field that is optional and use a composite whose first member
         * is not optional (constant or required). The specification does not clarify this however and some
         * implementations ignore this condition and allow encoding of the null value anyway, acting as if the
         * member was defined optional in the context of that field. 
         */
        // use default null value
        primChar   : char optional
        primInt8   : int8 optional
        primInt16  : int16 optional
        primInt32  : int32 optional
        primInt64  : int64 optional
        primUint8  : uint8 optional
        primUint16 : uint16 optional
        primUint32 : uint32 optional
        primUint64 : uint64 optional
        primFloat  : float optional
        primDouble : double optional
        // constant presence -----------------------------
        constChar   : char   constant='a'
        // FIXME: non-ascii literal should fail
        // constDelta   : char   constant='Δ'
        constInt8   : int8   constant=127
        constInt16  : int16  constant=32767
        constInt32  : int32  constant=2147483647
        constInt64  : int64  constant=9223372036854775807
        constUint8  : uint8  constant=255
        constUint16 : uint16 constant=65535
        constUint32 : uint32 constant=4294967295
        constUint64 : uint64 constant=18446744073709551615
// TODO: support float/double constants
//        constFloat  : float  constant=42
//        constDouble : double constant=42
        //
        // some illegal const value literals ------------
//      int_for_char_const    : char constant=42
//      char_for_uint8_const  : uint8 constant='x'
        //
        // override default null value
        nv_primChar   : char   nullValue='.'
        nv_primInt8   : int8   nullValue=42
        nv_primInt16  : int16  nullValue=42
        nv_primInt32  : int32  nullValue=42
        nv_primInt64  : int64  nullValue=42
        nv_primUint8  : uint8  nullValue=42
        nv_primUint16 : uint16 nullValue=42
        nv_primUint32 : uint32 nullValue=42
        nv_primUint64 : uint64 nullValue=42
// TODO: support float/double constants
//        nv_primFloat  : float nullValue=42
//        nv_primDouble : double nullValue=42
    // some illegal null value literals ------------
//      int_for_char_null     : char  nullValue=55
//      char_for_int8_null    : int8  nullValue='x'
//      char_for_uint8_null   : uint8 nullValue='x'
    /*
     * The set of members below reference enumerations, sets and simple types.
     * 
     * It is not possible to define presence for references to these types. For
     * simple types there is an alternative: just re-declare it as a member type
     * using its underlying primitive. For enumerations and sets (whether through
     * reference or inline) there is no way to set the presence of that member. 
     * 
     * The specification is lax on this topic. You can assume the presence is
     * required and design around this limitation, or you can assume the presence
     * is optional but you must use the default null value for the type (all bits
     * set for the underlying encoding type). Note that for sets were all bits are
     * used the default null value would collide with the case of all choices in
     * the set being active.
     * 
     * We treat presence modifiers as illegal, but leave it to the application to
     * decide which interpretation to use.
     */
    // types where presence  does not apply -------
//      int_for_enum_null     : EnumChar nullValue = 1
//      char_for_enum_null    : EnumChar nullValue = 'x'
//      int_for_enum_const    : EnumChar constant = 1
//      char_for_enum_const   : EnumChar constant = 'x'
//      enum_optional           : EnumChar optional
//      char_for_set_null     : Set32 nullValue = 'x'
//      int_for_set_null      : Set16 nullValue = 1
//      char_for_set_const    : Set32 constant = 'x'
//      int_for_set_const     : Set16 constant = 1
//      set_optional            : Set64 optional
//      simple_type_constant  : t_uint8 constant = 42
//      simple_type_nullValue : t_uint8 nullValue = 42
//      simple_type_optional  : t_uint8 optional
    }

    composite CompEverything
    {
        m_prim_int      : int32
        m_st_char       : t_char

        enum CompEverythingEnumNestedUint16 : uint16
        {
            ONE(1)
            TWO(2)
            THREE(3)
        }

        set CompEverythingSetNested32 : uint32
        {
            ZERO(0)
            THIRTY_ONE(31)
        }

        composite CompEverythingNestedComposite
        { // inline composite
            m_nested_prim   : uint16
            m_st_float      :   float
        }
        // m_ref_comp_array    : CompEnums[3] // length is illegal in composite references
        m_ref_comp_enum     : CompEnums
        m_ref_comp_sets     : CompSets
        m_ref_comp_prims   : CompPrimitives // reference composite
        m_ref_comp_simple   : CompSimpleTypes // reference composite
    }

    // this is required to exist (composite with name messageHeader ; can be overwritten by schema's headerType)
    composite messageHeader
    {
        // FIX SBE defaults to the composite with this name to use as the message header.
        // You can override it using the "headerType" keyword of the schema. The below
        // members are suggested (all required).
        blockLength : uint16 // size of message's fixed-length portion
        templateId : uint16 // message template identifier
        schemaId : uint16 // identifier of the schema defining the message
        ^version : uint16 // version of the schema used to create this message 
        // version is a keyword in sbelang; the ^ character escapes it
        numGroups : uint16 // number of repeating groups after fixed-length portion of message
        numVarDataFields : uint16 // number of variable data fields after fixed-length portion of message
    }
}

/*
 * Messages are very similar to composites.
 * 
 * The differences with composites are:
 * 
 * 1. Instead of a list of members you declare a list of fields, which are very similar
 * 2. After the list of fields you can declare groups
 * 3. After the list of groups you can declare variable-length data items
 * 
 * With regard to fields vs members: you cannot define inline types (simple/enum/set/composite)
 * so you must use only already-defined types from the types section above. While it is possible
 * to also use primitive types, those are the default ones with length 1. If you need fixed-length
 * arrays of char/int8/.../double you need to use simple types.
 * 
 * On the other hand, all fields can have presence defined (default is required), even fields that
 * of enum/composite type! Fields of enumeration type that are optional must be set to that
 * enumeration's NULL_VAL to indicate absence: you cannot override that value at the field level.
 * Optional fields of composite type indicate their absence by setting the first field of that
 * composite to null (or if that member is also a composite then recurse into the first member of
 * that). It is technically an error to define a field as optional if its type cannot be null. One
 * example is the set type which does not have a clearly defined null value in the specification.
 * Also composites where the first member is not of optional should not be used.
 * 
 */
message MessagePrimitives id=1
{
    t_char     : char @1 // member name does not collide with simple type
    primChar   : char @2
    primInt8  : int8 @3
    primInt16 : int16 @4
    primInt32 : int32 @5
    primInt64 : int64 @6
    primUint8  : uint8 @7
    primUint16 : uint16 @8
    primUint32 : uint32 @9
    primUint64 : uint64 @10
//   primChaR   : char @9999// same name in different letter case
//   primChar   : int8 @9999// exactly same name
    primFloat  : float @11
    primDouble : double @12
//  primCharArr : char[123] @2 // length not allowed for message fields, even on primitives!
}

message MessageSimpleTypes id=2
{
    t_char       : t_char @1 // member name does not collide with simple type
    st_char      : t_char @2
    st_int8      : t_int8 @3
    st_int16     : t_int16 @4
    st_int32     : t_int32 @5
    st_int64     : t_int64 @6
    st_uint8     : t_uint8 @7
    st_uint16    : t_uint16 @8
    st_uint32    : t_uint32 @9
    st_uint64    : t_uint64 @10
    // st_chAr   : char @9999// same name in different letter case
    // st_char   : t_char @9999// exactly same name
    st_float  : t_float @11
    st_double : t_double @12
//       st_char_array   : t_char[123] // length not allowed here!
//       st_enum_array   : EnumChar[123] // length not allowed here!
//       st_set_array   : Set32[123] // length not allowed here!
    arr_st_char  : array_char @13 // but you can refer to an array...
    arr_st_int32 : array_int32 @14
}

message MessageEnums id=3
{
    m_enum_char     : EnumChar @1
//   m_array_enum_char     : EnumChar[3] @9999 // length is illegal in enumeration references
    m_enum_uint8    : EnumUint8 @ 2
    m_enum_uint16   : EnumUint16 @ 3
}

message MessageSets id = 4
{
    m_set_8     : Set8 @ 1
    m_set_16    : Set16 @ 2
//   m_array_set_16     : Set16[3] @9999 // length is illegal in set references
    m_set_32    : Set32 @ 3
    m_set_64    : Set64 @ 4
}

message MessageRanges id = 5
{
    m_char_lower        : char @1 range=['a', 'z']
    m_int8_2_digits     : int8 @2 range=[-99, 99]
    m_int16_4_digits    : int16 @3 range = [-9999, 9999]
    m_int32_6_digits    : int32 @4 range = [-999999, 999999]
    m_int64_10_digit    : int64 @5 range = [-9999999999, 9999999999]
    // range specification errors -----------------------
//   m_char_range_inverted    : char  @90000 range=['z', 'a']
//   m_int_range_inverted     : int8  @90001 range=[5, -1]
//   m_uint_range_inverted    : uint8 @90002 range=[5, 0]
//   m_int_max_out_of_range   : int8  @90003 range=[1, 128]
//   m_uint_max_out_of_range  : uint8 @90004 range=[0, 256]
//   m_int_min_out_of_range   : int8  @90005 range=[-129, 127]
//   m_uint_min_out_of_range  : uint8 @90006 range=[-1, 255]
    m_uint8_2_digits    : uint8 @6 range=[0, 99]
    m_uint16_4_digits   : uint16 @7 range = [0, 9999]
    m_uint32_6_digits   : uint32 @8 range = [0, 999999]
    m_uint64_10_digit   : uint64 @9 range = [0, 9999999999]
    /*
     * Enums and sets cannot have a range as that is defined by the list of values. Composites cannot
     * have a range as it would not make sense (they comprise of many items each with its own range).
     * For each member of a composite the range is specified for by that item. Enums/sets automatically
     * define their range from their content and member data types can specify it as per below examples.
     * References to enums/sets use their target's range and REFERENCES TO SIMPLE TYPES CAN NOT have a
     * range but if one is required they can simply replace the reference with an inline member type
     * definition (same primitive/length but with range attribute).
     */
    m_float : float @10 // TODO: support float range
    m_double : double @11 // TODO: support double range
    // ------------------------------------------------------
    // Ranges can NOT be applied to simple type references
//  m_t_char_lower      : t_char   @90007 range = ['a', 'z']
//  m_t_int8_2_digits   : t_int8   @90008 range = [-99, 99]
//  m_t_int16_4_digits  : t_int16  @90009 range = [-9999, 9999]
//  m_t_int32_6_digits  : t_int32  @90010 range = [-999999, 999999]
//  m_t_int64_10_digit  : t_int64  @90011 range = [-9999999999, 9999999999]
//  m_enum_range        : EnumChar @90012 range = ['a','z']
//  m_set_range         : Set16    @90013 range = [1, 5]
}

message MessagePresence id = 6
{
        // use default null value
        primChar   : char @1 optional
        primInt8   : int8 @2 optional
        primInt16  : int16 @3 optional
        primInt32  : int32 @4 optional
        primInt64  : int64 @5 optional
        primUint8  : uint8 @6 optional
        primUint16 : uint16 @7 optional
        primUint32 : uint32 @8 optional
        primUint64 : uint64 @9 optional
        primFloat  : float @10 optional
        primDouble : double @11 optional
        // constant presence -----------------------------
        constChar   : char   @13 constant='a'
        // FIXME: non-ascii literal should fail
        // constDelta   : char   constant='Δ'
//      constInt8   : int8   constant=127
//      constInt16  : int16  constant=32767
//      constInt32  : int32  constant=2147483647
//      constInt64  : int64  constant=9223372036854775807 L
//      constUint8  : uint8  constant=255
//      constUint16 : uint16 constant=65535
//      constUint32 : uint32 constant=4294967295
//      constUint64 : uint64 constant=18446744073709551615
}

message MessageEverything id=9999
{
    m_prim_int          : int32           @1
    m_st_char           : t_char          @2
    m_ref_simple_array  : array_float     @3
    m_ref_comp_enum     : CompEnums       @4
    m_ref_comp_sets     : CompSets        @5
    m_ref_comp_prims    : CompPrimitives  @6
    m_ref_comp_simple   : CompSimpleTypes @7
    m_ref_comp_ranges   : CompRanges      @8
    m_ref_comp_presence : CompPresence    @9
}

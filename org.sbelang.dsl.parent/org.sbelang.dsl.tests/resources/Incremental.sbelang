schema org.sbelang.examples.v2.Incremental 
    id = 1 version = 100
//  headerType = a.b.c.D
//  bigEndian

types
{
    simpleType t_char : char
    simpleType t_int8 : int8
    simpleType t_int16 : int16
    simpleType t_int32 : int32
    simpleType t_int64 : int64
    simpleType t_uint8 : uint8
    simpleType t_uint16 : uint16
    simpleType t_uint32 : uint32
    simpleType t_uint64 : uint64
    // simpleType t_Char : int8 // same name in different letter case
    // simpleType t_char : int16 // exactly same name
    simpleType t_float : float
    simpleType t_double : double
    //
    // arrays --------------------------------
    //
    simpleType array_char : char[42]
    simpleType array_int8 : int8[16]
    simpleType array_int16 : int16[8]
    simpleType array_int32 : int32[4]
    simpleType array_int64 : int64[2]
    simpleType array_uint8 : uint8[16]
    simpleType array_uint16 : uint16[8]
    simpleType array_uint32 : uint32[4]
    simpleType array_uint64 : uint64[2]
    simpleType array_float : float[4]
    simpleType array_double : double[2]

    composite CompPrimitives
    {
        t_char     : char // member name does not collide with simple type
        primChar   : char
        primInt8  : int8
        primInt16 : int16
        primInt32 : int32
        primInt64 : int64
        primUint8  : uint8
        primUint16 : uint16
        primUint32 : uint32
        primUint64 : uint64
        // primChaR   : char // same name in different letter case
        // primChar   : int8 // exactly same name
        primFloat  : float
        primDouble : double
        //
        // arrays
        //
        arr_primChar   : char[24]
        arr_primInt8  : int8[16]
        arr_primInt16 : int16[8]
        arr_primInt32 : int32[4]
        arr_primInt64 : int64[2]
        arr_primUint8  : uint8[16]
        arr_primUint16 : uint16[8]
        arr_primUint32 : uint32[4]
        arr_primUint64 : uint64[2]
        arr_primFloat  : float[4]
        arr_primDouble : double[2]
    }

//    composite CompPrimitives { // composite name collides with existing composite
//        this_composite_name_should_collide_with_the_one_above : char
//    }
    composite CompSimpleTypes
    {
        t_char       : t_char // member name does not collide with simple type
        st_char      : t_char
        st_int8      : t_int8
        st_int16     : t_int16
        st_int32     : t_int32
        st_int64     : t_int64
        st_uint8     : t_uint8
        st_uint16    : t_uint16
        st_uint32    : t_uint32
        st_uint64    : t_uint64
        // st_chAr   : char // same name in different letter case
        // st_char   : t_char // exactly same name
        st_float  : t_float
        st_double : t_double
        // st_char_array   : t_char[123] // length not allowed here!
        arr_st_char  : array_char // but you can refer to an array...
        arr_st_int32 : array_int32
//   composite CompPrimitives {
//   this_composite_name_should_collide_with_the_one_above : char
//   }
    }

//  enum CompSimpleType { // composite name collides with enum
//      DUPLICATE_ENUM_NAME('X')
//  }
    enum EnumChar : char
    {
        YES('Y')
        NO('N')
    }

    enum EnumUint8 : uint8
    {
        YES(1)
        NO(0)
    }

    enum EnumUint16 : uint16
    {
        YES(10001)
        NO(10000)
    }

//  composite EnumUint8 { // composite name collides with enum
//      m_enum_char     : EnumChar
//  }
    composite CompEnums
    {
        m_enum_char     : EnumChar
        // m_array_enum_char     : EnumChar[3] // length is illegal in enum references
        m_enum_uint8    : EnumUint8
        m_enum_uint16   : EnumUint16

//      composite EnumUint8 { // composite name collides with enum
//          m_enum_char     : EnumChar
//      }
        enum EnumNestedChar : char
        {
            A('A')
            B('B')
            C('C')
        }
    }

    set Set8 : uint8
    {
        ZERO(0)
        SEVEN(7)
    }

    set Set16 : uint16
    {
        ZERO(0)
        FIFTEEN(15)
    }

    set Set32 : uint32
    {
        ZERO(0)
        THIRTY_ONE(31)
    }

    set Set64 : uint64
    {
        ZERO(0)
        SIXTY_THREE(63)
    }

//  composite Set16 {
//      m_set_32     : Set32
//  }
    composite CompSets
    {
        m_set_8     : Set8
        m_set_16    : Set16
        // m_array_set_16     : Set16[3] // length is illegal in set references
        m_set_32    : Set32
        m_set_64    : Set64

//      composite Set16 {
//          m_set_32     : Set32
//      }
        set SetNested16 : uint16
        {
            NESTED_ZERO(0)
            NESTED_FIFTEEN(15)
        }
    }

    composite CompEverything
    {
        m_prim_int      : int32
        m_st_char       : t_char

//      enum EnumNestedChar : char {
//          X('X')
//      }
        enum EnumNestedUint16 : uint16
        {
            ONE(1)
            TWO(2)
            THREE(3)
        }

//      set Set32 : uint32 {
//          ZERO(0)
//      }
        set SetNested32 : uint32
        {
            ZERO(0)
            THIRTY_ONE(31)
        }

        composite CompEverythingNested
        { // inline composite
            m_nested_prim   : uint16
            m_st_float      :   float
        }
        // m_ref_comp_array    : CompEnums[3] // length is illegal in composite references
        m_ref_comp_enum     : CompEnums
        m_ref_comp_sets     : CompSets
        m_ref_comp_prims   : CompPrimitives // reference composite
        m_ref_comp_simple   : CompSimpleTypes // reference composite
    }

    /*================================================================================================
     * The section above covers all core features. Every kind of type declaration (simple/enum/set and
     * composite) is demonstrated, along with all kinds of inline/reference members for composites. We
     * also covered arrays (from simple types or member types that are primitives) and finally we have
     * provided commented-out examples for all kinds of syntactically-correct but semantically-illegal
     * cases (unique member names in same composite/enum/set, unique names for inline sets enumerations
     * and composites across the entire schema).
     * 
     * 
     * 
     */
    // this is required to exist (composite with name messageHeader ; can be overwritten by schema's headerType)
    composite messageHeader
    {
        // FIX SBE defaults to the composite with this name to use as the message header.
        // You can override it using the "headerType" keyword of the schema. The below
        // members are suggested (all required).
        blockLength : uint16 // size of message's fixed-length portion
        templateId : uint16 // message template identifier
        schemaId : uint16 // identifier of the schema defining the message
        ^version : uint16 // version of the schema used to create this message 
        // version is a keyword in sbelang; the ^ character escapes it
        numGroups : uint16 // number of repeating groups after fixed-length portion of message
        numVarDataFields : uint16 // number of variable data fields after fixed-length portion of message
    }
}

message MessageOne id=1
{
    f_comp_everything : CompEverything @ 1
}

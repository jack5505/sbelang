schema org.sbelang.examples.v2.AllFeatures 
    id = 1 version = 100
//  headerType = a.b.c.D
//  bigEndian

types
{
    // ==========================================================================================
    // SIMPLE TYPES
    //
    // Simple types reference one of the primitive type (char, integers of 8/16/32/64 bits with
    // or without sign, and the float/double IEEE types). The only data type specialisation that
    // simple types allow is to add a fixed length, thus allowing one to define arrays, which is
    // the primary reason to use a simple type.
    //
    // TODO: char types should also allow "characterEncoding" attribute but that's not implemented yet
    //
    // Of course, the version attributes can also be defined.
    //
    // SIMPLE TYPES WITH NO ATTRIBUTES (defaults: length=1, since=0, deprecated=n/a)
    // ------------------------------------------------------------------------------------------
    simpleType t_char : char
    simpleType t_int8 : int8
    simpleType t_int16 : int16
    simpleType t_int32 : int32
    simpleType t_int64 : int64
    simpleType t_uint8 : uint8
    simpleType t_uint16 : uint16
    simpleType t_uint32 : uint32
    simpleType t_uint64 : uint64
    simpleType t_float : float
    simpleType t_double : double
    // ------------------------------------------------------------------------------------------
    // SIMPLE TYPES WITH NO LENGTH - VERSION ATTRIBUTE COMBINATIONS
    simpleType t_char_s : char sinceVersion=1 // since only
    simpleType t_char_d : char deprecatedSinceVersion=2 // deprecated only
    simpleType t_char_sd : char sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_int8_s : int8 sinceVersion=2
    simpleType t_int8_d : int8 deprecatedSinceVersion=3
    simpleType t_int8_sd : int8 sinceVersion=3 deprecatedSinceVersion=4
    simpleType t_int16_s : int16 sinceVersion=3
    simpleType t_int16_d : int16 deprecatedSinceVersion=4
    simpleType t_int16_sd : int16 sinceVersion=5 deprecatedSinceVersion=6
    simpleType t_int32_s : int32 sinceVersion=4
    simpleType t_int32_d : int32 deprecatedSinceVersion=5
    simpleType t_int32_sd : int32 sinceVersion=7 deprecatedSinceVersion=8
    simpleType t_int64_s : int64 sinceVersion=5
    simpleType t_int64_d : int64 deprecatedSinceVersion=6
    simpleType t_int64_sd : int64 sinceVersion=9 deprecatedSinceVersion=10
    simpleType t_uint8_s : uint8 sinceVersion=6
    simpleType t_uint8_d : uint8 deprecatedSinceVersion=7
    simpleType t_uint8_sd : uint8 sinceVersion=11 deprecatedSinceVersion=12
    simpleType t_uint16_s : uint16 sinceVersion=7
    simpleType t_uint16_d : uint16 deprecatedSinceVersion=8
    simpleType t_uint16_sd : uint16 sinceVersion=13 deprecatedSinceVersion=14
    simpleType t_uint32_s : uint32 sinceVersion=8
    simpleType t_uint32_d : uint32 deprecatedSinceVersion=9
    simpleType t_uint32_sd : uint32 sinceVersion=15 deprecatedSinceVersion=16
    simpleType t_uint64_s : uint64 sinceVersion=9
    simpleType t_uint64_d : uint64 deprecatedSinceVersion=10
    simpleType t_uint64_sd : uint64 sinceVersion=17 deprecatedSinceVersion=18
    simpleType t_float_s : float sinceVersion=10
    simpleType t_float_d : float deprecatedSinceVersion=11
    simpleType t_float_sd : float sinceVersion=19 deprecatedSinceVersion=20
    simpleType t_double_s : double sinceVersion=11
    simpleType t_double_d : double deprecatedSinceVersion=12
    simpleType t_double_sd : double sinceVersion=21 deprecatedSinceVersion=22
    // uncomment the two lines below to see errors in versions
    // simpleType t_SinceDep_After_Schema : char sinceVersion=1000 deprecatedSinceVersion=500
    // simpleType t_DepNotAfterSince : char sinceVersion=50 deprecatedSinceVersion=50
    // ------------------------------------------------------------------------------------------
    // SIMPLE TYPES WITH LENGTH 1
    // length = 1 (this is a special case as it is not serialized as an array)
    simpleType t_char_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_char_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_char_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_int8_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_int8_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_int8_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_uint8_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_uint8_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_uint8_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_int16_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_int16_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_int16_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_uint16_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_uint16_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_uint16_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_int32_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_int32_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_int32_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_uint32_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_uint32_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_uint32_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_int64_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_int64_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_int64_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_uint64_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_uint64_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_uint64_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_float_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_float_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_float_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    simpleType t_double_l1_s : char[1] sinceVersion=1 // since only
    simpleType t_double_l1_d : char[1] deprecatedSinceVersion=2 // deprecated only
    simpleType t_double_l1_sd : char[1] sinceVersion=1 deprecatedSinceVersion=2 // both
    // ------------------------------------------------------------------------------------------
    // SIMPLE TYPES WITH LENGTH > 1; (VERSION COMBOS RANDOMLY ASSINGED)
    simpleType t_charArray : char[42]
    simpleType t_int8Array : int8[2] sinceVersion=1
    simpleType t_int16Array : int16[3] deprecatedSinceVersion=2
    simpleType t_int32Array : int32[4] sinceVersion=11 deprecatedSinceVersion=99
    simpleType t_int64Array : int64[5]
    simpleType t_uint8Array : uint8[2]
    simpleType t_uint16Array : uint16[3]
    simpleType t_uint32Array : uint32[4]
    simpleType t_uint64Array : uint64[5]
    simpleType t_floatArray : float[2]
    simpleType t_doubleArray : double[3]
    // some simple types as arrays (length greater than one) with versions
    simpleType t_charArray_sd : char[42] sinceVersion=1 deprecatedSinceVersion=2
    simpleType t_int16Array_s : int16[3] sinceVersion=1
    simpleType t_int32Array_d : int32[4] deprecatedSinceVersion=2

    // ==========================================================================================
    // ENUMERATIONS
    //
    // We support enumerations of 3 types: char/uint8/uint16. There is an implied NULL_VAL entry
    // with a default value for each type: 0/255/65535 respectively. If NULL_VAL is explicitly
    // provided then it overrides that default, but this should be done when the enumeration is
    // first-introduced otherwise changing it later would break compatibility (the null value may
    // or may not be in use: it depends on whether there are references from composites or fields
    // in messages).
    //
    // Enumerations manifest only when they are used for a field or composite member, so like
    // simple types they have no business-semantic attributes like "presence" or "min/max range".
    // In fact the latter does not apply to enumerations anyway (there is no range for an
    // enumeration: it specifies a list of valid values in itself).
    //
    // ------------------------------------------------------------------------------------------
    // First define all 3 types (char/uint8/uint16) without specifying a NULL_VAL
    enum E_Char : char sinceVersion=10 deprecatedSinceVersion=20
    {
        YES('Y')
        // YES('y') // invalid because the name collides with YES('Y')
        // YES_DUPLICATE('Y') // invalid because the value collides with YES
        THINK_YES('y')
        NO('N')
        THINK_NO('n') sinceVersion=11
        MAYBE('M') deprecatedSinceVersion=20
        NOT_SURE('?') sinceVersion=11 deprecatedSinceVersion=19
    // illegal versions compared to entire schema version (can't talk about the future)
    // -------------------------------------------------------
    // AFTER_SCHEMA_VERSION_ERROR_SINCE('v') sinceVersion=101
    // AFTER_SCHEMA_VERSION_ERROR_DEPRECATED('w') deprecatedSinceVersion=101
    // illegal in itself: you must deprecate some time after initially adding
    // -------------------------------------------------------
    // MUST_DEPRECATE_AFTER_SINCE_ERROR('w') sinceVersion=10 deprecatedSinceVersion=10
    // illegal versions compared to this enum version (can't be older than enum itself)
    // -------------------------------------------------------
    // VALUE_VERSION_BEFORE_ENUM_DEFINED_ERROR('d') sinceVersion=9
    // VALUE_VERSION_AFTER_ENUM_ALREADY_DEPRECATED_ERROR('d') sinceVersion=20
    // VALUE_DEPRECATED_NOT_AFTER_ENUM_DEFINED_ERROR('e') deprecatedSinceVersion=10
    // VALUE_DEPRECATED_NOT_AFTER_ENUM_DEPRECATED_ERROR('f') deprecatedSinceVersion=21
    }

    enum E_Uint8 : uint8 sinceVersion=1
    {
        ZERO(0)
        ONE(1)
        TWO_HUNDRED_AND_FIFTY_FOUR(254)
    // RESERVED_FOR_NULL(255) // invalid as 255 is uint8 nullValue
    // OUT_OF_RANGE(256) // invalid as 256 outside value range of uint8
    }

    enum E_Uint16 : uint16 deprecatedSinceVersion=2
    {
        YES(0)
        NO(1)
        TWO_HUNDRED_AND_FIFTY_FIVE(255)
    // RESERVED_FOR_NULL(65535) // invalid as 65535 is uint16 nullValue
    // OUT_OF_RANGE(65536) // invalid as 65536 outside value range of uint16
    }

    // ------------------------------------------------------------------------------------------
    // Now define all 3 types (char/uint8/uint16) by specifying a NULL_VAL that MATCHES the 
    // default value, so essentially that has no effect
    enum E_Char_nvd : char
    {
        ONE('1')
        TWO('2')
        NULL_VAL('\000') // note that '\ddd' where d is a digit is parsed as a number (BASE 10)
    }

    enum E_Uint8_nvd : uint8
    {
        ZERO(0)
        ONE(1)
        TWO_HUNDRED_AND_FIFTY_FOUR(254)
        NULL_VAL(255)
    }

    enum E_Uint16_nvd : uint16
    {
        YES(0)
        NO(1)
        TWO_HUNDRED_AND_FIFTY_FIVE(255)
        NULL_VAL(65535)
    }

    // ------------------------------------------------------------------------------------------
    // Now define all 3 types (char/uint8/uint16) by specifying a NULL_VAL that OVERRIDES the 
    // default value, meaning it is different from that
    enum E_Char_nvo : char
    {
        ONE('1')
        TWO('2')
        NULL_VAL(' ') // space character is null value here
    }

    enum E_Uint8_nvo : uint8
    {
        ZERO(0)
        ONE(1)
        TWO_HUNDRED_AND_FIFTY_FOUR(254)
        NULL_VAL(42)
    // RESERVED_FOR_NULL(255) // invalid as 255 remains reserved for uint8 nullValue
    }

    enum E_Uint16_nvo : uint16
    {
        YES(0)
        NO(1)
        TWO_HUNDRED_AND_FIFTY_FIVE(255)
        NULL_VAL(42)
    // RESERVED_FOR_NULL(65535) // invalid as 65535 remains reserved for uint16 nullValue
    }

    // ==========================================================================================
    // SETS (of choices)
    //
    // Here we support 4 types: uint8/uint16/uint32/uint64. Again sets behave like simple types
    // in the same way enumeration do: they have no concept of presence and their range is in
    // fact defined by the list of possible values (on/off flags) of their content with anything
    // other bits ignored.
    //
    // There is no null value for sets so fields/composite-members that use them cannot be
    // optional.
    //
    // ------------------------------------------------------------------------------------------
    // Define all 3 types (char/uint8/uint16) without of sets
    set S_uint8 : uint8
    {
        BIT_0(0)
        BIT_1(1)
        // BIT_1(3) // invalid because the name collides with BIT_1(1)
        // BIT_2(1)  // invalid because value collides with BIT_1(1)
        BIT_7(7)
    // OUT_OF_RANGE(8) // invalid as 8 outside value range of uint8
    }

    set S_uint16 : uint16 sinceVersion=1
    {
        BIT_0(0)
        BIT_1(1)
        // BIT_1(3) // invalid because the name collides with BIT_1(1)
        // BIT_2(1)  // invalid because value collides with BIT_1(1)
        BIT_8(8)
        BIT_15(15)
    // OUT_OF_RANGE(16) // invalid as 8 outside value range of uint16
    }

    set S_uint32 : uint32 deprecatedSinceVersion=2
    {
        BIT_0(0)
        BIT_1(1)
        // BIT_1(3) // invalid because the name collides with BIT_1(1)
        // BIT_2(1)  // invalid because value collides with BIT_1(1)
        BIT_8(8)
        BIT_16(16)
        BIT_31(31)
    // OUT_OF_RANGE(33) // invalid as 8 outside value range of uint32
    }

    set S_uint64 : uint64 sinceVersion=10 deprecatedSinceVersion=20
    {
        BIT_0(0)
        BIT_1(1)
        // BIT_1(3) // invalid because the name collides with BIT_1(1)
        // BIT_2(1)  // invalid because value collides with BIT_1(1)
        // VERSION_ERRORS(42) sinceVersion=1000 deprecatedSinceVersion=500
        BIT_8(8) sinceVersion=10
        BIT_32(32) deprecatedSinceVersion=11
        BIT_63(63) sinceVersion=10 deprecatedSinceVersion=20
    // OUT_OF_RANGE(64) // invalid as 8 outside value range of uint64
    // illegal versions compared to entire schema version (can't talk about the future)
    // -------------------------------------------------------
    // AFTER_SCHEMA_VERSION_ERROR_SINCE(20) sinceVersion=101
    // AFTER_SCHEMA_VERSION_ERROR_DEPRECATED(21) deprecatedSinceVersion=101
    // illegal in itself: you must deprecate some time after initially adding
    // -------------------------------------------------------
    // MUST_DEPRECATE_AFTER_SINCE_ERROR(22) sinceVersion=10 deprecatedSinceVersion=10
    // illegal versions compared to this set version (can't be older than set itself)
    // -------------------------------------------------------
    // VALUE_VERSION_BEFORE_SET_DEFINED_ERROR(23) sinceVersion=9
    // VALUE_VERSION_AFTER_SET_ALREADY_DEPRECATED_ERROR(24) sinceVersion=20
    // VALUE_DEPRECATED_NOT_AFTER_SET_DEFINED_ERROR(25) deprecatedSinceVersion=10
    // VALUE_DEPRECATED_NOT_AFTER_SET_DEPRECATED_ERROR(26) deprecatedSinceVersion=21
    }

    // ==========================================================================================
    // COMPOSITES
    //
    // Macro-like definitions for creating complex types by combining multiple types. Composites
    // have members that can be primitive types, simple types, enumerations, sets or other
    // composites.
    //
    // You can also define inline enumerations/sets/nested-composites, which are only usable
    // within this composite and are not reusable outside this composite.
    //
    // As composites are higher-order types, their members can define the missing attributes such
    // as presence, min/max value and null value.
    //
    // The composite as a whole can be used for group/message fields or reference from other
    // composites.
    // ==========================================================================================
    //
    // First the special FIX SBE composites: messageHeader, groupSizeEncoding, DATA
    // ------------------------------------------------------------------------------------------
    composite messageHeader
    {
        // FIX SBE defaults to the composite with this name to use as the message header.
        // You can override it using the "headerType" keyword of the schema. The below
        // members are suggested (all required).
        blockLength : uint16 // size of message's fixed-length portion
        templateId : uint16 // message template identifier
        schemaId : uint16 // identifier of the schema defining the message
        ^version : uint16 // version of the schema used to create this message 
        // version is a keyword in sbelang; the ^ character escapes it
        numGroups : uint16 // number of repeating groups after fixed-length portion of message
        numVarDataFields : uint16 // number of variable data fields after fixed-length portion of message
    }

    composite groupSizeEncoding
    {
        // FIX SBE defaults to the composite with this name to use as the group header.
        // You can override it using the "dimensionType" keyword. The below  members are 
        // suggested (all required).
        blockLength : uint16 // fixed-length portion of the group
        numInGroup : uint16 // number of items in the gorup
        numGroups : uint16
        numVarDataFields2 : uint16
    }

    composite DATA
    {
        // FIX SBE recommends using this declaration for variable-length data fields.
        length : uint16 // number of bytes (octets)
        varData : uint8[0] // a length of zero means variable length
    }

    // Demonstrate referencing simple types, enums; define presence and min/max/null
    // ------------------------------------------------------------------------------------------
    composite CompPrimitives
    {
        // You can set either 'nullValue' or 'optional', not both. Specifying a nullValue makes the
        // presence optional. In order to use the default null value and not specify one, just mark
        // the member as 'optional' which uses the default null value for that type. You cannot set
        // both as it is illegal. Setting neither means the field is required
        //
        // All these are required fields with default range; null value is default but not applicable 
        primChar : char
        primIint8 : int8
        primIint16 : int16
        primIint32 : int32
        primIint64 : int64
        primUint8 : uint8
        primUint16 : uint16
        primUint32 : uint32
        primUint64 : uint64
        // -----------------------------------------------------------------------------------------
        // Set custom attributes for range and null value; setting a null value makes these optional
        lowerCaseChar : char range=['a','z'] nullValue=' ' // lower with space meaning absent
        month : int8 range=[1,12] nullValue = -1 // e.g. for a month; -1 means absent
        yeadAD : uint16 range=[0, 64999] nullValue = 65000 // e.g. for a month; -1 means absent
        // -----------------------------------------------------------------------------------------
        // Optional primitives without a range, just presence
        optionalChar : char optional // default null value
        optionalCharWithSpaceForNull : char nullValue = ' ' // special null value
        marksTheSpotChar : char constant = 'X' // constant presence (character literal)
        zero : int8 constant = 0 // constant presence (integer)
        // -----------------------------------------------------------------------------------------
        // Required primitives with range; null value not applicable
        requiredChar : char range=['A', 'Z']
        // -----------------------------------------------------------------------------------------
        // TODO: set length
    }

    // Demonstrate referencing simple types, enums; define presence and min/max/null
    // ------------------------------------------------------------------------------------------
    // Here, the length (if any) is set by the simple type. We can only specify presence and
    // also restrict the range if necessary
    composite CompSimpleTypes
    {
        stRequiredChar : t_char // just use it as a required field
        // -----------------------------------------------------------------------------------------
        // TODO: Specify range ; currently not accepted here
        stUpperCaseChar : t_char // range=['A','Z'] // just use it as a required field
    }

    composite TestReferencesComposite
    {
        ref_st_uint16 : t_uint16
        ref_st_doubleArray : t_doubleArray
        ref_enum : E_Uint16
        ref_set : S_uint32
        ref_composite : messageHeader
    }

    composite TestCompositeAttrs sinceVersion=1 deprecatedSinceVersion=2
    {
        cChar : char
        // cChar : uint32 // duplicate name inside this composite
        refE : t_char
        // refE : t_char
    }

    composite TestComposite
    {
        cChar : char
        cConstantChar : char constant = 'a'
        refE : t_char
        cInt8 : int8 constant = -128
        cInt16 : int16 optional
        cInt32 : int32 range=[-1,1]
        cInt64 : int64
        cUInt8 : uint8 constant = 1
        cUInt16 : uint16
        cUInt32 : uint32
        cUInt64 : uint64
        rFloatArray : t_floatArray
        cCharArray : char[42]
        cInt8Array : int8[16]
        cInt16Array : int16[8] range=[1,]
        cInt32Array : int32[4] range=[,10]
        cInt64Array : int64[2] range=[1,10]
        cUInt8Array : uint8[16]
        cUInt16Array : uint16[8] optional
        cUInt32Array : uint32[4] nullValue=42
        cUInt64Array : uint64[2]

        enum ce_Uint16 : uint16
        {
            NESTED_NO(0)
            NESTED_YES(1)
        }

        composite TestCompositeNested
        {
            nestedInt8 : int8

            composite TestCompositeNestedNested
            {
                nestedNestedInt8 : int8
            }
        }
        cCharMinMax : char range=['a','d'] nullValue='a'
        cInt8Min : int8 range = [-128,127]
        cUInt8Min : uint8 range = [0,127]
        cInt32Min : int8 range = [-1,]
        cInt32Max : int32 range = [,100]
        cInt32MinMax : int32 range = [11 , 99]
        cInt32MinOpt : int32 range = [1,] optional
        cInt32MaxOpt : int32 range = [,100] nullValue = 0
        cInt32MinMaxOpt : int32 range = [-111 , -9] nullValue = -1
        cInt32MinConst : int32 constant = 2 // negative constant required

        composite TestCompositeSecondNested
        {
            nestedInt8 : int8
        }
    }
}

message MsgEnumerations id=1
{
    f_e_Char : E_Char @ 1 // FIXME: optional
    f_e_Char_nvd : E_Char_nvd @ 2 // FIXME: optional
    f_e_Char_nvo : E_Char_nvo @ 3 // FIXME: optional
    f_e_Uint8 : E_Uint8 @ 4
    f_e_Uint8_nvd : E_Uint8_nvd @ 5
    f_e_Uint8_nvo : E_Uint8_nvo @ 6
    f_e_Uint16 : E_Uint16 @ 7
    f_e_Uint16_nvd : E_Uint16_nvd @ 8
    f_e_Uint16_nvo : E_Uint16_nvo @ 9
}

message TestMessage2 id=2
{
    fChar : char @ 1 // Not supported by SBE tool yet: constant = 'a'
    fUint8 : uint8 @ 2 // Not supported by SBE tool yet: constant = 1
    fInt8 : t_int8 @ 3 // Not supported by SBE tool yet: constant = 127
    fInt8Array : t_int16Array @ 4 sinceVersion = 1 deprecatedSinceVersion = 2
    fEnumChar : E_Char @ 5 // constant = TODO: support reference to enum value
    fSetUint8 : S_uint8 @ 6
    fTestComposite : TestComposite @ 7

    group TestGroup id = 8
    {
        gfDoubleArray : t_doubleArray @ 1
        gfEnumTopLevelUint8 : E_Uint8 @ 2
        gfSetTopLevelUint16 : S_uint16 @ 3
        gfTestCompositeAttrs : TestCompositeAttrs @ 4 sinceVersion = 2
    }

    data
    {
        fVarRawData1 : DATA @ 9
        fVarRawData2 : DATA @ 9
    }
}

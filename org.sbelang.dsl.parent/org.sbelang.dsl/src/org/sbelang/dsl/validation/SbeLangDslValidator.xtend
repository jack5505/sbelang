/*
 * generated by Xtext 2.13.0
 */
package org.sbelang.dsl.validation

import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.validation.Check
import org.sbelang.dsl.SbeLangDslValueUtils
import org.sbelang.dsl.sbeLangDsl.CompositeMember
import org.sbelang.dsl.sbeLangDsl.CompositeTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.EnumDeclaration
import org.sbelang.dsl.sbeLangDsl.EnumValueDeclaration
import org.sbelang.dsl.sbeLangDsl.MemberRefTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.MessageSchema
import org.sbelang.dsl.sbeLangDsl.PresenceConstantModifier
import org.sbelang.dsl.sbeLangDsl.PresenceOptionalModifier
import org.sbelang.dsl.sbeLangDsl.SbeLangDslPackage
import org.sbelang.dsl.sbeLangDsl.SetChoiceDeclaration
import org.sbelang.dsl.sbeLangDsl.SetDeclaration
import org.sbelang.dsl.sbeLangDsl.SimpleTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.VersionModifiers

import static org.sbelang.dsl.SbeLangDslValueUtils.isValidLiteral
import org.sbelang.dsl.sbeLangDsl.BlockDeclaration
import org.sbelang.dsl.sbeLangDsl.FieldDeclaration
import org.sbelang.dsl.sbeLangDsl.RangeModifiers
import org.sbelang.dsl.sbeLangDsl.PresenceModifiers
import org.sbelang.dsl.sbeLangDsl.TypeDeclaration
import org.eclipse.emf.ecore.EReference

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SbeLangDslValidator extends AbstractSbeLangDslValidator {

    public static val CHAR_PRIMITIVE = 'char'

    public static val NULL_VAL = 'NULL_VAL'

    // TODO: add check for unique IDs for each message in schema
    // TODO: add check for unique names for messages and groups
    // TODO: add check for char literals to ensure they're not out of ASCII range (e.g. Greek delta letter)
    @Check
    def checkAllTypeNamesAreUnique(MessageSchema messageSchema) {
        try {
            validateAllTypeNamesAreUnique(messageSchema.typeDelcarations.map[t|new NameDeclaration(t.name, t)],
                new HashMap<String, EObject>())
        } catch (Exception e) {
            e.printStackTrace
        }
    }

    @Check
    def checkMemberType(MemberRefTypeDeclaration mtd) {
        validatePresenceModifiers(mtd.presence, mtd.type, mtd.primitiveType,
            SbeLangDslPackage.Literals.MEMBER_REF_TYPE_DECLARATION__PRESENCE)
    }

    @Check
    def checkSet(SetDeclaration sd) {
        val maxValidBitIdx = switch (sd.encodingType) {
            case 'uint8': 7
            case 'uint16': 15
            case 'uint32': 31
            case 'uint64': 63
            default: -1
        }

        val Map<String, SetChoiceDeclaration> names = new HashMap()
        val Map<Integer, SetChoiceDeclaration> values = new HashMap()
        for (choice : sd.setChoices) {
            val existingName = names.put(choice.name, choice)
            if (existingName !== null) {
                val existingNode = NodeModelUtils.getNode(existingName)
                error(
                    '''Duplicate (case-insensitive) name [«choice.name»]; previous declaration at line «existingNode.startLine»''',
                    choice,
                    SbeLangDslPackage.Literals.SET_CHOICE_DECLARATION__NAME
                )
            }
            if ((choice.value < 0) || (choice.value > maxValidBitIdx))
                error(
                    '''Value is [«choice.value»] is ouside the valid range of [0,«maxValidBitIdx»] for «sd.encodingType»!''',
                    choice,
                    SbeLangDslPackage.Literals.SET_CHOICE_DECLARATION__VALUE
                )

            val existingValue = values.put(choice.value, choice)
            if (existingValue !== null) {
                val existingNode = NodeModelUtils.getNode(existingValue)
                error(
                    '''Value is [«choice.value»] collides with value of «existingValue.name» in line «existingNode.startLine»!''',
                    choice,
                    SbeLangDslPackage.Literals.SET_CHOICE_DECLARATION__VALUE
                )
            }

            if ((sd.versionModifiers !== null) && (choice.versionModifiers !== null)) {
                validateVersionAgainstContainer(choice.versionModifiers, sd.versionModifiers, choice,
                    SbeLangDslPackage.Literals.SET_CHOICE_DECLARATION__VERSION_MODIFIERS)
            }
        }
    }

    @Check
    def checkEnum(EnumDeclaration ed) {
        val Map<String, EnumValueDeclaration> names = new HashMap()
        val Map<String, EnumValueDeclaration> values = new HashMap()
        for (ev : ed.enumValues) {
            val existingName = names.put(ev.name, ev)
            if (existingName !== null) {
                val existingNode = NodeModelUtils.getNode(existingName)
                error(
                    '''Duplicate (case-insensitive) name [«ev.name»]; previous declaration at line «existingNode.startLine»''',
                    ev,
                    SbeLangDslPackage.Literals.ENUM_VALUE_DECLARATION__NAME
                )
            }

            val existingValue = values.put(ev.value, ev)
            if (existingValue !== null) {
                val existingNode = NodeModelUtils.getNode(existingValue)
                error(
                    '''Duplicate value [«ev.value»]; previous declaration at line «existingNode.startLine»''',
                    ev,
                    SbeLangDslPackage.Literals.ENUM_VALUE_DECLARATION__VALUE
                )
            }

            if (!isValidLiteral(ev.value, ed.encodingType)) {
                error(
                    '''Value is [«ev.value»] which is outside the valid range for encoding type [«ed.encodingType»]!''',
                    ev,
                    SbeLangDslPackage.Literals.ENUM_VALUE_DECLARATION__VALUE
                )
            }

            if (ev.value.toString == reservedNullValue(ed.encodingType).toString) {
                if (NULL_VAL != ev.name)
                    error(
                        '''Value [«ev.value»] is reserved for null in [«ed.encodingType»]!''',
                        ev,
                        SbeLangDslPackage.Literals.ENUM_VALUE_DECLARATION__VALUE
                    )
            }

            if ((ed.versionModifiers !== null) && (ev.versionModifiers !== null)) {
                validateVersionAgainstContainer(ev.versionModifiers, ed.versionModifiers, ev,
                    SbeLangDslPackage.Literals.ENUM_VALUE_DECLARATION__VERSION_MODIFIERS)
            }
        }
    }

    @Check
    def checkRangeIsProper(MemberRefTypeDeclaration mptd) {
        validateRangeModifiers(mptd.range, mptd.presence, mptd.primitiveType, mptd.type,
            SbeLangDslPackage.Literals.MEMBER_REF_TYPE_DECLARATION__RANGE)
    }

    @Check
    def checkField(FieldDeclaration field) {
        validateRangeModifiers(
            field.range,
            field.presence,
            field.primitiveType,
            field.type,
            SbeLangDslPackage.Literals.FIELD_DECLARATION__RANGE
        )
        validatePresenceModifiers(
            field.presence,
            field.type,
            field.primitiveType,
            SbeLangDslPackage.Literals.FIELD_DECLARATION__PRESENCE
        )
    }

    private def validatePresenceModifiers(PresenceModifiers presence, TypeDeclaration type, String primitiveType,
        EReference errorMarkerTarget) {
        switch type {
            case null: {
                switch presence {
                    PresenceConstantModifier: {
                        validatePresenceConstant(presence, primitiveType)
                    }
                    PresenceOptionalModifier: {
                        if (!presence.isOptional) {
                            validatePresenceNullValue(presence, primitiveType)
                        }
                    }
                }
            }
            SetDeclaration: {
                if (presence !== null)
                    error(
                        '''Presence cannot be applied to sets.''',
                        errorMarkerTarget
                    )
            }
            EnumDeclaration: {
                if (presence !== null)
                    error(
                        '''Presence cannot be applied to enum.''',
                        errorMarkerTarget
                    )
            }
            SimpleTypeDeclaration: {
                if (presence !== null)
                    error(
                        '''Presence cannot be applied to simple type reference. You should just use the primitive type [«(type as SimpleTypeDeclaration).primitiveType»] directy''',
                        errorMarkerTarget
                    )
            }
        }
    }

    private def validateRangeModifiers(RangeModifiers range, PresenceModifiers presence, String primitiveType,
        TypeDeclaration type, EReference errorMarkerTarget) {
        // basic checks for existence or constant presence
        if(range === null) return; // no range can't be wrong
        if (presence !== null) { // if constant, range does not make sense...
            if (presence instanceof PresenceConstantModifier)
                error(
                    "You can't specify a range for a constant!",
                    errorMarkerTarget
                )
        }

        // check their relative value; min cannot exceed max regardless of anything else
        if ((range.min !== null) && (range.max !== null)) {
            switch (primitiveType) {
                case 'char': {
                    val min = SbeLangDslValueUtils.parseCharacter(range.min)
                    val max = SbeLangDslValueUtils.parseCharacter(range.max)

                    if (min.isPresent && max.isPresent)
                        if (min.get.compareTo(max.get) > 0)
                            error(
                                '''Minimum range of («range.min») cannot exceed maximum of («range.max»)''',
                                errorMarkerTarget
                            )
                }
                default: { // assume number...
                    val min = SbeLangDslValueUtils.parseBigDecimal(range.min)
                    val max = SbeLangDslValueUtils.parseBigDecimal(range.max)
                    if (min.isPresent && max.isPresent)
                        if (min.get.compareTo(max.get) > 0)
                            error(
                                '''Minimum range of («range.min») cannot exceed maximum of («range.max»)''',
                                errorMarkerTarget
                            )
                }
            }
        }

        // check the literals; if it's not a primitive type, must pick up from reference type
        if (primitiveType !== null) {
            if (!isValidLiteral(range.min.toString, primitiveType)) {
                error(
                    '''Minimum range of («range.min») is not within range of type («primitiveType»)''',
                    errorMarkerTarget
                )
            }
            if (!isValidLiteral(range.max.toString, primitiveType)) {
                error(
                    '''Maximum range of («range.max») is not within range of type («primitiveType»)''',
                    errorMarkerTarget
                )
            }
        } else {
            /*
             * Enums and sets cannot have a range as that is defined by the list of values. Composites cannot
             * have a range as it would not make sense (they comprise of many items each with its own range).
             * For each member of a composite the range is specified for by that item. Enums/sets automatically
             * define their range from their content and member data types can specify it as per below examples.
             * References to enums/sets use their target's range and REFERENCES TO SIMPLE TYPES CAN NOT have a
             * range but if one is required they can simply replace the reference with an inline member type
             * definition (same primitive/length but with range attribute).
             */
            // reject range for reference to anything other than simple type
            if (type instanceof SimpleTypeDeclaration) {
                val st = type as SimpleTypeDeclaration
                error(
                    '''Range cannot be applied to simple type reference. You should just use the primitive type [«st.primitiveType»] directy''',
                    errorMarkerTarget
                )
            } else {
                error(
                    '''Range cannot be applied to this type''',
                    errorMarkerTarget
                )
            }
        }
    }

    @Check
    def checkVersionModifiersAgainstSchemaVersion(VersionModifiers vm) {
        val ms = EcoreUtil.getRootContainer(vm) as MessageSchema

        if (vm.sinceVersion !== null) {
            if (vm.sinceVersion > ms.schema.version) {
                error(
                    '''The sinceVersion(«vm.sinceVersion») value cannot be greater than the schema version(«ms.schema.version») value!''',
                    vm,
                    SbeLangDslPackage.Literals.VERSION_MODIFIERS__SINCE_VERSION
                )
            }

            if (vm.deprecatedSinceVersion !== null) {
                if (vm.deprecatedSinceVersion <= vm.sinceVersion) {
                    error(
                        '''The deprecatedSinceVersion(«vm.deprecatedSinceVersion») value must be greater than the since version(«vm.sinceVersion») value!''',
                        vm,
                        SbeLangDslPackage.Literals.VERSION_MODIFIERS__DEPRECATED_SINCE_VERSION
                    )
                }
            }
        }

        if (vm.deprecatedSinceVersion !== null) {
            if (vm.deprecatedSinceVersion > ms.schema.version) {
                error(
                    '''The deprecatedSinceVersion(«vm.deprecatedSinceVersion») value cannot be greater than the schema version(«ms.schema.version») value!''',
                    vm,
                    SbeLangDslPackage.Literals.VERSION_MODIFIERS__DEPRECATED_SINCE_VERSION
                )
            }
        }
    }

    @Check
    def checkLengthModifier(MemberRefTypeDeclaration memberRef) {
        if ((memberRef.length !== null) && (memberRef.type !== null)) {
            error('''Only composite members of primitive type are allowed to have fixed length''', memberRef,
                SbeLangDslPackage.Literals.MEMBER_REF_TYPE_DECLARATION__LENGTH)
        }
    }

    @Check
    def checkComposite(CompositeTypeDeclaration ctd) {
        val Map<String, CompositeMember> names = new HashMap()
        for (cm : ctd.compositeMembers) {
            if (cm instanceof MemberRefTypeDeclaration) {
                val existingName = names.put(cm.name.toUpperCase, cm)
                if (existingName !== null) {
                    val existingNode = NodeModelUtils.getNode(existingName)
                    error(
                        '''Duplicate (case-insensitive) name [«cm.name»]; previous declaration at line «existingNode.startLine»''',
                        cm,
                        SbeLangDslPackage.Literals.MEMBER_REF_TYPE_DECLARATION__NAME
                    )
                }
            }
        }
    }

    @Check
    def checkBlock(BlockDeclaration bd) {
        val Map<String, FieldDeclaration> names = new HashMap()
        for (cm : bd.fieldDeclarations) {
            val existingName = names.put(cm.name.toUpperCase, cm)
            if (existingName !== null) {
                val existingNode = NodeModelUtils.getNode(existingName)
                error(
                    '''Duplicate (case-insensitive) name [«cm.name»]; previous declaration at line «existingNode.startLine»''',
                    cm,
                    SbeLangDslPackage.Literals.FIELD_DECLARATION__NAME
                )
            }
        }
    }

    // INTERNALS ------------------------------------------------------
    private def validatePresenceConstant(PresenceConstantModifier constantModifier, String primitiveType) {
        if (! isValidLiteral(constantModifier.constantValue, primitiveType)) {
            error('''The constant value [«constantModifier.constantValue»] is not valid for the type [«primitiveType»]''',
                constantModifier, SbeLangDslPackage.Literals.PRESENCE_CONSTANT_MODIFIER__CONSTANT_VALUE)
        }
    }

    private def validatePresenceNullValue(PresenceOptionalModifier optionalModifier, String primitiveType) {
        if (! isValidLiteral(optionalModifier.nullValue, primitiveType)) {
            error('''The null value [«optionalModifier.nullValue»] is not valid for the type [«primitiveType»]''',
                optionalModifier, SbeLangDslPackage.Literals.PRESENCE_OPTIONAL_MODIFIER__NULL_VALUE)
        }
    }

    private static class NameDeclaration {
        String name;
        EObject declaringObject;

        new(String n, EObject o) {
            this.name = n
            this.declaringObject = o
        }
    }

    private def validateVersionAgainstContainer(VersionModifiers toValidate, VersionModifiers containerVersions,
        EObject errorTarget, EStructuralFeature errorTargetAttr) {
        if (toValidate.sinceVersion !== null) {
            if ((containerVersions.sinceVersion !== null) &&
                (toValidate.sinceVersion < containerVersions.sinceVersion)) {
                error(
                    '''Can not have a [sinceVersion=«toValidate.sinceVersion»] in the past relative to container's [sinceVersion=«containerVersions.sinceVersion»]''',
                    errorTarget,
                    errorTargetAttr
                )
            }
            if ((containerVersions.deprecatedSinceVersion !== null) &&
                (toValidate.sinceVersion >= containerVersions.deprecatedSinceVersion)) {
                error(
                    '''Can not have a [sinceVersion=«toValidate.sinceVersion»] after container is already deprecated [deprecatedSinceVersion=«containerVersions.deprecatedSinceVersion»]''',
                    errorTarget,
                    errorTargetAttr
                )
            }
        }

        if (toValidate.deprecatedSinceVersion !== null) {
            if ((containerVersions.sinceVersion !== null) &&
                (toValidate.deprecatedSinceVersion <= containerVersions.sinceVersion)) {
                error(
                    '''The [deprecatedSinceVersion=«toValidate.deprecatedSinceVersion»] must be after the container's [sinceVersion=«containerVersions.sinceVersion»]''',
                    errorTarget,
                    errorTargetAttr
                )
            }
            if ((containerVersions.deprecatedSinceVersion !== null) &&
                (toValidate.deprecatedSinceVersion > containerVersions.deprecatedSinceVersion)) {
                error(
                    '''Can not have a [deprecatedSinceVersion=«toValidate.deprecatedSinceVersion»] after container is already deprecated [deprecatedSinceVersion=«containerVersions.deprecatedSinceVersion»]''',
                    errorTarget,
                    errorTargetAttr
                )
            }
        }
    }

    private def void validateAllTypeNamesAreUnique(List<NameDeclaration> nameDeclarations, Map<String, EObject> names) {
        nameDeclarations.forEach [ nd |
            if (nd !== null) {
                val existing = names.put(nd.name.toUpperCase, nd.declaringObject)
                if (existing !== null) {
                    val existingNode = NodeModelUtils.getNode(existing)
                    val featureId = switch nd.declaringObject {
                        MemberRefTypeDeclaration:
                            SbeLangDslPackage.Literals.MEMBER_REF_TYPE_DECLARATION__NAME
                        default: // all others are descendants of type declaration
                            SbeLangDslPackage.Literals.TYPE_DECLARATION__NAME
                    }
                    error(
                        '''Duplicate (case-insensitive) name [«nd.name»]; previous declaration at line «existingNode.startLine»''',
                        nd.declaringObject,
                        featureId
                    )
                }
                if (nd.declaringObject instanceof CompositeTypeDeclaration) {
                    val composite = nd.declaringObject as CompositeTypeDeclaration
                    validateAllTypeNamesAreUnique(composite.compositeMembers.map [ cm |
                        switch cm {
                            // MemberPrimitiveTypeDeclaration and MemberRefTypeDeclaration are confined within composites
                            // so they are more like fields: they are NOT reusable types. Uniqueness check should be local
                            // ------------------------------------------------------------------------------------------------
                            // MemberPrimitiveTypeDeclaration:
                            // new NameDeclaration(cm.name, cm)
                            // MemberRefTypeDeclaration:
                            // new NameDeclaration(cm.name, cm)
                            SetDeclaration:
                                new NameDeclaration(cm.name, cm)
                            EnumDeclaration:
                                new NameDeclaration(cm.name, cm)
                            CompositeTypeDeclaration:
                                new NameDeclaration(cm.name, cm)
                        }
                    ], names)
                }

            }
        ]
    }

    def long reservedNullValue(String enumType) {
        switch enumType {
            case 'char': 0
            default: SbeLangDslValueUtils.maxValue(enumType).toBigInteger.longValue
        }
    }

}

/*
 * generated by Xtext 2.14.0
 */
package org.sbelang.dsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.sbelang.dsl.sbeLangDsl.BlockDeclaration
import org.sbelang.dsl.sbeLangDsl.CompositeMember
import org.sbelang.dsl.sbeLangDsl.CompositeTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.EnumDeclaration
import org.sbelang.dsl.sbeLangDsl.EnumValueDeclaration
import org.sbelang.dsl.sbeLangDsl.FieldDeclaration
import org.sbelang.dsl.sbeLangDsl.GroupDeclaration
import org.sbelang.dsl.sbeLangDsl.MessageSchema
import org.sbelang.dsl.sbeLangDsl.RawVariableDataDeclaration
import org.sbelang.dsl.sbeLangDsl.SchemaDeclaration
import org.sbelang.dsl.sbeLangDsl.SetChoiceDeclaration
import org.sbelang.dsl.sbeLangDsl.SetDeclaration
import org.sbelang.dsl.services.SbeLangDslGrammarAccess

class SbeLangDslFormatter extends AbstractFormatter2 {

    @Inject extension SbeLangDslGrammarAccess

    def dispatch void format(MessageSchema messageSchema, extension IFormattableDocument document) {
        val typesOpen = messageSchema.regionFor.keyword("{")
        val typesClose = messageSchema.regionFor.keyword("}")
        typesOpen.surround[newLine]
        typesClose.prepend[newLine]
        interior(typesOpen, typesClose, [indent])
        messageSchema.schema.format

        if (messageSchema.typeDelcarations !== null) {
            for (typeDeclaration : messageSchema.typeDelcarations) {
                switch typeDeclaration {
                    EnumDeclaration:
                        typeDeclaration.prepend[newLines = 2]
                    SetDeclaration:
                        typeDeclaration.prepend[newLines = 2]
                    CompositeTypeDeclaration:
                        typeDeclaration.prepend[newLines = 2]
                    default:
                        typeDeclaration.prepend[newLine]
                }
                typeDeclaration.format
            }
        }

        if (messageSchema.messageDeclarations !== null) {
            for (messageDeclaration : messageSchema.messageDeclarations) {
                messageDeclaration.prepend[newLines = 2]
                messageDeclaration.format
            }
        }
    }

    def dispatch void format(SchemaDeclaration schemaDeclaration, extension IFormattableDocument document) {
        // TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
        schemaDeclaration.optionalAttrs.format
    }

    def dispatch void format(EnumDeclaration enumDeclaration, extension IFormattableDocument document) {
        val typesOpen = enumDeclaration.regionFor.keyword("{")
        val typesClose = enumDeclaration.regionFor.keyword("}")
        typesOpen.surround[newLine]
        typesClose.prepend[newLine]
        interior(typesOpen, typesClose, [indent])

        if (enumDeclaration.enumValues !== null) {
            for (EnumValueDeclaration evd : enumDeclaration.enumValues) {
                evd.prepend[newLine]
            }
        }
    }

    def dispatch void format(SetDeclaration setDeclaration, extension IFormattableDocument document) {
        val typesOpen = setDeclaration.regionFor.keyword("{")
        val typesClose = setDeclaration.regionFor.keyword("}")
        typesOpen.surround[newLine]
        typesClose.prepend[newLine]
        interior(typesOpen, typesClose, [indent])

        if (setDeclaration.setChoices !== null) {
            for (SetChoiceDeclaration scd : setDeclaration.setChoices) {
                scd.prepend[newLine]
            }
        }
    }

    def dispatch void format(CompositeTypeDeclaration compositeTypeDeclaration,
        extension IFormattableDocument document) {
        val typesOpen = compositeTypeDeclaration.regionFor.keyword("{")
        val typesClose = compositeTypeDeclaration.regionFor.keyword("}")
        typesOpen.surround[newLine]
        typesClose.prepend[newLine]
        interior(typesOpen, typesClose, [indent])

        if (compositeTypeDeclaration.compositeMembers !== null) {
            for (CompositeMember cm : compositeTypeDeclaration.compositeMembers) {
                switch cm {
                    EnumDeclaration: {
                        cm.prepend[newLines = 2]
                        format(cm, document)
                    }
                    SetDeclaration: {
                        cm.prepend[newLines = 2]
                        format(cm, document)
                    }
                    CompositeTypeDeclaration: {
                        cm.prepend[newLines = 2]
                        format(cm, document)
                    }
                    default:
                        cm.prepend[newLine]
                }
            }
        }
    }

    def dispatch void format(BlockDeclaration blockDeclaration, extension IFormattableDocument document) {
        val typesOpen = blockDeclaration.regionFor.keyword("{")
        val typesClose = blockDeclaration.regionFor.keyword("}")
        typesOpen.surround[newLine]
        typesClose.prepend[newLine]
        interior(typesOpen, typesClose, [indent])

        if (blockDeclaration.fieldDeclarations !== null) {
            for (FieldDeclaration fd : blockDeclaration.fieldDeclarations) {
                fd.prepend[newLine]
            }
        }

        if (blockDeclaration.groupDeclarations !== null) {
            for (GroupDeclaration gd : blockDeclaration.groupDeclarations) {
                gd.prepend[newLines = 2]
                format(gd.block, document)
            }
        }

        if (blockDeclaration.rawDataBlockDeclaration !== null) {
            blockDeclaration.rawDataBlockDeclaration.prepend[newLines = 2]

            val dataOpen = blockDeclaration.rawDataBlockDeclaration.regionFor.keyword("{")
            val dataClose = blockDeclaration.rawDataBlockDeclaration.regionFor.keyword("}")
            dataOpen.surround[newLine]
            dataClose.prepend[newLine]
            interior(dataOpen, dataClose, [indent])

            if (blockDeclaration.rawDataBlockDeclaration.varDataDeclarations !== null) {
                for (RawVariableDataDeclaration rvdd : blockDeclaration.rawDataBlockDeclaration.varDataDeclarations) {
                    rvdd.prepend[newLine]
                }
            }
        }
    }

// TODO: implement for SimpleTypeDeclaration, EnumValueDeclaration, SetChoiceDeclaration, MemberRefTypeDeclaration, MemberPrimitiveTypeDeclaration, MessageDeclaration, GroupDeclaration, FieldDeclaration,
}

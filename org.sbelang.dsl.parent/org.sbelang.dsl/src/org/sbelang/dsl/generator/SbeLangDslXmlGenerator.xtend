/*
 * generated by Xtext 2.13.0
 */
package org.sbelang.dsl.generator

import java.nio.ByteOrder
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sbelang.dsl.generator.intermediate.ImMessageSchema
import org.sbelang.dsl.generator.xml.XmlMessageSchema
import org.sbelang.dsl.sbeLangDsl.BlockDeclaration
import org.sbelang.dsl.sbeLangDsl.CompositeMember
import org.sbelang.dsl.sbeLangDsl.CompositeTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.EnumDeclaration
import org.sbelang.dsl.sbeLangDsl.GroupDeclaration
import org.sbelang.dsl.sbeLangDsl.MemberRefTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.RawDataBlockDeclaration
import org.sbelang.dsl.sbeLangDsl.SetDeclaration
import org.sbelang.dsl.sbeLangDsl.SimpleTypeDeclaration
import org.sbelang.dsl.sbeLangDsl.VersionModifiers
import org.sbelang.dsl.sbeLangDsl.FieldDeclaration
import org.sbelang.dsl.sbeLangDsl.PresenceConstantModifier
import org.sbelang.dsl.SbeLangDslValueUtils
import org.sbelang.dsl.sbeLangDsl.PresenceOptionalModifier
import org.eclipse.emf.ecore.EObject

/**
 * Generates XML from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SbeLangDslXmlGenerator extends SbeLangDslBaseGenerator {

    public static val genXml = Boolean.valueOf(
        System.getProperty(typeof(SbeLangDslGenerator).package.name + ".genXml", "true"))

    override void compile(ImMessageSchema imSchema, IFileSystemAccess2 fsa, IGeneratorContext context) {
        if(!genXml) return;

        val xmlSchema = new XmlMessageSchema(imSchema)

        fsa.generateFile(
            imSchema.schemaName + '.xml',
            '''
                <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                <sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                    xsi:schemaLocation="http://fixprotocol.io/2016/sbe/sbe.xsd"
                    
                    package="«imSchema.schemaName»"
                    id="«imSchema.schemaId»" version="«imSchema.schemaVersion»"«optionalAttrs(xmlSchema)»>
                    
                    <types>
                        «FOR type : imSchema.rawSchema.typeDelcarations.filter(SimpleTypeDeclaration)»
                            «compile(type)»
                        «ENDFOR»
                        
                        «FOR type : imSchema.rawSchema.typeDelcarations.filter(EnumDeclaration)»
                            «compile(type)»
                        «ENDFOR»
                        
                        «FOR type : imSchema.rawSchema.typeDelcarations.filter(SetDeclaration)»
                            «compile(type)»
                        «ENDFOR»
                        
                        «FOR compositeType : imSchema.rawSchema.typeDelcarations.filter(CompositeTypeDeclaration)»
                            «compile(compositeType)»
                        «ENDFOR»
                    </types>
                    
                    «FOR message : imSchema.rawSchema.messageDeclarations»
                        «compile("message", message.block)»
                    «ENDFOR»
                </sbe:messageSchema>
            '''
        )
    }

    private def String compile(String tag, BlockDeclaration block) {
        compile(tag, null, block)
    }

    private def String compile(String tag, String dimensionType, BlockDeclaration block) {
        '''
            <«tag» name="«block.name»" id="«block.id»"«IF dimensionType !== null» dimensionType="«dimensionType»"«ENDIF»>
                «FOR field : block.fieldDeclarations»
                    «compile(field)»
                «ENDFOR»
                «FOR group : block.groupDeclarations»
                    «compile("group", dimensionTypeName(group), group.block)»
                «ENDFOR»
                «compile(block.rawDataBlockDeclaration)»
            </«tag»>
        '''
    }

    private def compile(RawDataBlockDeclaration dataBlock) {
        if(dataBlock === null) return ''''''
        '''
            «FOR dataField : dataBlock.varDataDeclarations»
                <data name="«dataField.name»" id="«dataField.id»" type="«dataField.dataEncodingType.name»" />
            «ENDFOR»
        '''
    }

    private def dimensionTypeName(GroupDeclaration group) {
        if (group.dimensionType === null)
            null
        else
            group.dimensionType.name
    }

    private def compile(SimpleTypeDeclaration std) {
        '''
            <type name="«std.name»" primitiveType="«std.primitiveType»"«simpleTypeLength(std)»«versionAttrs(std.versionModifiers)»/>
        '''
    }

    private def simpleTypeLength(SimpleTypeDeclaration std) {
        '''«IF std.length !== null» length="«std.length»"«ENDIF»'''
    }

    private def versionAttrs(VersionModifiers vm) {
        if (vm !== null) {

            val sinceV = vm.sinceVersion;
            val depV = vm.deprecatedSinceVersion;

            '''«IF sinceV !== null» sinceVersion="«sinceV»"«ENDIF»«IF depV !== null» deprecated="«depV»"«ENDIF»'''
        } else {
            ""
        }
    }

    private def optionalAttrs(XmlMessageSchema xmlSchema) {
        '''«headerTypeAttr(xmlSchema.imSchema)»«byteOrderAttr(xmlSchema)»'''
    }

    private def headerTypeAttr(ImMessageSchema imSchema) {
        '''«IF imSchema.headerTypeName !== null» headerType="«imSchema.headerTypeName»"«ENDIF»'''
    }

    private def byteOrderAttr(XmlMessageSchema xmlMessageSchema) {
        '''«IF xmlMessageSchema.imSchema.schemaByteOrder !== ByteOrder.LITTLE_ENDIAN» byteOrder="«xmlMessageSchema.byteOrderAttribute»"«ENDIF»'''
    }

    private def String compile(CompositeTypeDeclaration ctd) {
        '''
            <composite name="«ctd.name»"«versionAttrs(ctd.versionModifiers)»>
                «FOR cm : ctd.compositeMembers»
                    «compile(cm)»
                «ENDFOR»
            </composite>
        '''
    }

    private def compile(CompositeMember cm) {
        if (cm instanceof MemberRefTypeDeclaration)
            compile(cm /* as MemberRefTypeDeclaration */ )
        else if (cm instanceof CompositeTypeDeclaration)
            compile(cm /* as CompositeTypeDeclaration */ )
        else if (cm instanceof EnumDeclaration)
            compile(cm /* as EnumDeclaration */ )
        else if (cm instanceof SetDeclaration)
            compile(cm /* as SetDeclaration */ )
        else
            throw new IllegalStateException("Unsupported composite member: " + cm.class.name)
    }

    private def compile(MemberRefTypeDeclaration mtd) {
        // TODO: handle nullValue
        
        if (mtd.primitiveType === null) {
            '''
                <ref name="«mtd.name»" type="«mtd.type.name»" />
            '''
        } 
        else {
            '''
                <type name="«mtd.name»" primitiveType="«mtd.primitiveType»"«memberTypeLength(mtd)»«memberTypeRange(mtd)»«presenceAttrs(mtd.presence)»«closeTag("type", mtd.presence)»
            '''
        }
    }

    private def compile(EnumDeclaration ed) {
        '''
            <enum name="«ed.name»" encodingType="«ed.encodingType»"«versionAttrs(ed.versionModifiers)»>
                «FOR enumVal : ed.enumValues»
                    «IF "NULL_VAL" == enumVal.name»
                        <!--
                        WARNING: SBE Tool currently always adds a "NULL_VAL" to enumerations with the default null value. If you supply
                        an overrides (or just explicitly state the default) for NULL_VAL a bug in SBE Tool will produce broken code.
                        
                        <validValue name="NULL_VAL"«versionAttrs(enumVal.versionModifiers)»>«constLiteral(enumVal.value)»</validValue>
                        -->
                    «ELSE»
                        <validValue name="«enumVal.name»"«versionAttrs(enumVal.versionModifiers)»>«constLiteral(enumVal.value)»</validValue>
                    «ENDIF»
                «ENDFOR»
            </enum>
        '''
    }

    private def compile(SetDeclaration sd) {
        '''
            <set name="«sd.name»" encodingType="«sd.encodingType»"«versionAttrs(sd.versionModifiers)»>
                «FOR setChoice : sd.setChoices»
                    <choice name="«setChoice.name»"«versionAttrs(setChoice.versionModifiers)»>«setChoice.value»</choice>
                «ENDFOR»
            </set>
        '''
    }


    private def memberTypeLength(MemberRefTypeDeclaration mtd) {
        '''«IF mtd.length !== null» length="«mtd.length»"«ENDIF»'''
    }

    private def memberTypeRange(MemberRefTypeDeclaration mtd) {
        if (mtd.rangeModifiers !== null)
            '''«IF mtd.rangeModifiers.min !== null» minValue="«constLiteral(mtd.rangeModifiers.min)»"«ENDIF»«IF mtd.rangeModifiers.max !== null» maxValue="«constLiteral(mtd.rangeModifiers.max)»"«ENDIF»'''
    }

    def compile(FieldDeclaration field) {
        val fieldType = if(field.primitiveType === null) field.fieldType.name else field.primitiveType
        '''
            <field name="«field.name»" id="«field.id»" type="«fieldType»"«presenceAttrs(field.presenceModifiers)»«versionAttrs(field.versionModifiers)»«closeTag("field", field.presenceModifiers)»
        '''
    }

    def closeTag(String tag, EObject presence) {
        switch presence {
            PresenceConstantModifier: {
                val constant = constLiteral(presence.constantValue)
                '''>«constant»</«tag»>'''
            }
            // PresenceOptionalModifier
            default: '''/>'''
        }
    }

    private def constLiteral(String value) {
        val oc = SbeLangDslValueUtils.parseCharacter(value)
        if (oc.present)
            oc.get.toString
        else {
            val oi = SbeLangDslValueUtils.parseBigInteger(value)
            if (oi.present)
                oi.get.toString
            else {
                val od = SbeLangDslValueUtils.parseBigDecimal(value)
                od.get.toString
            }
        }
    }

    private def presenceAttrs(Object presence) {
        switch presence {
            PresenceOptionalModifier: ''' presence="optional"'''
            PresenceConstantModifier: ''' presence="constant"'''
            default: ''''''
        }
    }
}

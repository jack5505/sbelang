/*
 * generated by Xtext 2.13.0
 */
package org.sbelang.dsl.generator

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sbelang.dsl.sbeLangDsl.BlockType
import org.sbelang.dsl.sbeLangDsl.CompositeType
import org.sbelang.dsl.sbeLangDsl.EncodedDataType
import org.sbelang.dsl.sbeLangDsl.EnumType
import org.sbelang.dsl.sbeLangDsl.EnumValue
import org.sbelang.dsl.sbeLangDsl.Field
import org.sbelang.dsl.sbeLangDsl.Group
import org.sbelang.dsl.sbeLangDsl.Message
import org.sbelang.dsl.sbeLangDsl.Specification
import org.sbelang.dsl.sbeLangDsl.TypeDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SbeLangDslGenerator extends AbstractGenerator {
    val String OPTIONAL_PRESENCE_MODIFIER = "?"
    val char CHAR_LITERAL_DELIMITER = '\''

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val spec = resource.getEObject("/") as Specification
        val types = spec.types.types
        val messages = spec.messages

        fsa.generateFile(
            resource.URI.lastSegment + '.xml',
            '''
                <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                <sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" package="Examples" id="91" version="0"
                    byteOrder="littleEndian" xsi:schemaLocation="http://fixprotocol.io/2016/sbe sbe.xsd">
                    
                    «IF types.size > 0»
                    <types>
                        «generateTypeDeclarations(types)»
                    </types>
                    «ENDIF»
                    «IF messages.size > 0»
                    «generateMessages(messages)»
                    «ENDIF»
                    
                </sbe:messageSchema>
            '''
        )
    }
    
    def String generateTypeDeclarations(EList<TypeDeclaration> typeDecls) {
        '''
            «FOR section : typeDecls»
                «section.compile»
            «ENDFOR»
        '''
    }

    def compile(TypeDeclaration typeDecl) {
        switch typeDecl {
            EncodedDataType:
                if ((typeDecl.presence !== null) && (OPTIONAL_PRESENCE_MODIFIER != typeDecl.presence) )
                // not null and not optional: is a constant
                '''
                    <type name="«typeDecl.name»" presence="constant" «IF typeDecl.length !== null»length="«typeDecl.length.length»" «ENDIF»primitiveType="«typeDecl.primitiveType»"«IF typeDecl.semanticType !== null» semanticType="«typeDecl.semanticType.description»"«ENDIF»>«getPresenceConstant(typeDecl.presence)»</type>
                '''
                else
                // required (default) or optional
                '''
                    <type name="«typeDecl.name»" «IF OPTIONAL_PRESENCE_MODIFIER == typeDecl.presence»presence="optional" «ENDIF»«IF typeDecl.length !== null»length="«typeDecl.length.length»" «ENDIF»primitiveType="«typeDecl.primitiveType»"«IF typeDecl.semanticType !== null» semanticType="«typeDecl.semanticType.description»"«ENDIF» />
                '''
            CompositeType: '''
                <composite name="«typeDecl.name»"«IF typeDecl.semanticType !== null» semanticType="«typeDecl.semanticType.description»"«ENDIF»>
                    «generateTypeDeclarations(typeDecl.types)»
                </composite>
            '''
            EnumType: '''
                <enum name="«typeDecl.name»" encodingType="«typeDecl.enumEncodingType.name»">
                    «generateEnumValidValues(typeDecl.eContents)»
                </enum>
            '''
            default:
                throw new IllegalStateException("Don't know how to handle: " + typeDecl.class)
        }
    }
    
    def String getPresenceConstant(String presenceString) {
        val trimmed = presenceString.trim
        if (!trimmed.startsWith("="))
            throw new IllegalStateException("Was expecting a presence constant!")
        trimmed.substring(1).trim // ditch equals sign...
    }

    def generateEnumValidValues(EList<EObject> enumValues) {
        '''
            «FOR v : enumValues.filter(EnumValue)»
                <validValue name="«v.name»">«unQuote(v.value)»</validValue>
            «ENDFOR»
        '''
    }

    def unQuote(String enumValue) {
        if (enumValue.length >= 3) {
            if ((enumValue.charAt(0) == CHAR_LITERAL_DELIMITER) && (enumValue.charAt(2) == CHAR_LITERAL_DELIMITER)) {
                return "" + enumValue.charAt(1)
            }
        }
        return enumValue;
    }

    def generateMessages(EList<Message> messages) {
        '''
        «FOR m : messages»

        <sbe:message name="«m.name»" id="«m.id»"«IF m.semanticType !== null» semanticType="«m.semanticType.description»"«ENDIF»>
            «generateBlock(m.block)»
        </sbe:message>
        «ENDFOR»
        '''
    }
    
    def String generateBlock(BlockType block) {
        '''
            «IF block.fieldsList !== null»
            «FOR f : block.fieldsList.fields»
                «generateField(f)»
            «ENDFOR»
            «ENDIF»
            «IF block.groupList !== null»
            
            «FOR g : block.groupList.groups»
                «generateGroup(g)»
            «ENDFOR»
            «ENDIF»
            «IF block.dataList !== null»
            
            «FOR d : block.dataList.dataFields»
                «generateDataField(d)»
            «ENDFOR»
            «ENDIF»
        '''
    }
    
    def generateField(Field f) {
        // FIXME: optional presence modifier is ignored...
        '''
            <field name="«f.name»" id="«f.id»" type="«f.fieldEncodingType.name»"«IF f.semanticType !== null» semanticType="«f.semanticType.description»"«ENDIF» />
        '''
    }
    
    def generateGroup(Group g) {
        '''
            <group name="«g.name»" id="«g.id»" dimensionType="«g.groupEncodingType.name»">
                «generateBlock(g.block)»
            </group>
        '''
    }

    def generateDataField(Field f) {
        '''
            <data name="«f.name»" type="«f.fieldEncodingType.name»" id="«f.id»"«IF f.semanticType !== null» semanticType="«f.semanticType.description»"«ENDIF» />
        '''
    }
}
